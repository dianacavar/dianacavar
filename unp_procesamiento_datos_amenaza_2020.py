# -*- coding: utf-8 -*-
"""UNP PROCESAMIENTO DATOS_AMENAZA_2020

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KrKhdy_S8VRcHXhilk31Cnh7fW9bCnrt

#UNP BASE DE DATOS DE LAS EVALUACIONES DE NIVEL DE RIESGO SUSTENTADAS EN AMENAZA

# Librerias
"""

!pip install sodapy

import pandas as pd
from sodapy import Socrata
import numpy as np
import seaborn as sns

"""##Librerias para visualización"""

import matplotlib.pylab as plt # Herramienta principal de visualización https://matplotlib.org/stable/contents.html
import matplotlib.dates as mdates # Dentro de matplotlib, tenemos una herramienta para manejo de fechas 
import seaborn as sbn # Herramienta complementaria de visualización https://seaborn.pydata.org/

"""# Lectura de la fuente de datos (Publica)"""

client = Socrata("www.datos.gov.co", None)
results = client.get("gafa-aef3", limit=35000) # Con limite de 1.000 filas (Filas 3,98M)

df = pd.DataFrame.from_records(results)

"""# Limpieza de datos"""

df.head(5)

# Convierte las columnas tipo objeto a fecha
df['a_o'] = pd.to_datetime(df['a_o'])
df.dtypes

# Calcula algunas estadisticas descriptivas/ incluso las categoricas
print(df.describe(include="all"))

# frecuencias por variables de las ENR sustentadas en amenaza
print("frecuencia por mes", df["mes"].value_counts())
print("frecuencia por departamento",df["depto_riesgo"].value_counts())
print("frecuencia por municipio",df["municipio_riesgo"].value_counts())
print("frecuencia por género",df["genero"].value_counts())
print("frecuencia por grupo poblacional",df["grupopob"].value_counts())
print("frecuencia por categoria",df["categoria"].value_counts())
print("frecuencia por ponderación",df["ponderacion"].value_counts())
print("frecuencia por subversión",df["subversion"].value_counts())
print("frecuencia por autor conocido",df["conocido"].value_counts())
print("frecuencia por causa laboral",df["laboral"].value_counts())
print("frecuencia por autor GAO",df["grupos_armados"].value_counts())
print("frecuencia por forma escrita",df["escrita"].value_counts())
print("frecuencia por causa personal",df["personal"].value_counts())
print("frecuencia por autor delincuencia organizada",df["delincuencia_organizada"].value_counts())
print("frecuencia por forma telefonica",df["telefonica"].value_counts())
print("frecuencia por causa politica",df["politico"].value_counts())
print("frecuencia por autor delincuencia comun",df["delincuencia_comun"].value_counts())
print("frecuencia por forma medios magneticos",df["medios_magneticos"].value_counts())
print("frecuencia por causa economica",df["economico"].value_counts())
print("frecuencia por causa personal_1",df["personal_1"].value_counts())
print("frecuencia por forma informacion de terceros",df["informacion_terceros"].value_counts())
print("frecuencia por causa ideologico",df["ideologico"].value_counts())
print("frecuencia por autor desconocido",df["desconocido"].value_counts())
print("frecuencia por forma objeto simbolico",df["obj_simbolico"].value_counts())
print("frecuencia por forma verbal",df["verbal"].value_counts())

"""FRECUENCIAS RELATIVAS"""

# tabla de frecuencia relativa de Ponderacion 
print("frecuencia relativa por ponderación  \n",round(df["ponderacion"].value_counts()/ len(df["ponderacion"]* 100),2))

#Tambien se puede de esta forma sacar la frecuencia relativa
round(df["ponderacion"].value_counts(normalize= True, ascending=False),2)

"""##VISUALIZACION"""

from matplotlib.pyplot import xlabel
#Gráfico de barras absoluto
plot = df['ponderacion'].value_counts().plot(kind='bar', title='Nivel de riesgo de las ENR')

#Gráfico de torta
plot = df['ponderacion'].value_counts().plot(kind='pie', autopct='%.2f', 
                                            figsize=(6, 6),
                                            title='% NR')

#GRAFICO DE POBLACIONES
df['grupopob'].value_counts(ascending=True).plot(kind='barh' )

#GRAFICO FRECUENCIA RELATIVA
freq_rel = df['grupopob'].value_counts(normalize=True, ascending=True)
# Gráfico de barras con frecuencias relativas
freq_rel.plot(kind='barh', width=0.8, figsize=(9,4), color= "#FFD700")

"""##RELACION DE VARIABLES"""

#TABLA DE CONTINGENCIA ENTRE POBLACION Y PONDERACION 

pd.crosstab(index=df['grupopob'],
            columns=df['ponderacion'] , margins=True)

#TABLA DE CONTINGENCIA ENTRE GENERO Y PONDERACION ...El margins son los totales

round(pd.crosstab(index=df['genero'],
            columns=df['ponderacion'],margins=True, normalize = True),2)

#GRAFICA DE BARRAS ENTRE GENERO Y PONDERACION
plot= pd.crosstab(index=df['ponderacion'],
            columns=df['genero'], normalize = True).plot(kind='barh')

"""###PRUEBA CHI-CUADRADO"""

#TABLA DE CONTINGENCIA 3 VARIABLES 

# Creamos una tabla de contingencia con las tres variables
tabla_contingencia = pd.crosstab(index=[df['grupopob'], df['genero']], columns=df['ponderacion'], margins=True).head(3)

print(tabla_contingencia)

# Realizamos la prueba de chi-cuadrado
from scipy.stats import chi2_contingency
chi2, p, dof, expected = chi2_contingency(tabla_contingencia)

# Imprimimos los resultados
print('Estadístico de prueba chi-cuadrado: ', chi2)
print('Valor p: ', p)
print('Grados de libertad: ', dof)
"print('Frecuencias esperadas: ', expected)"

# Creamos una tabla de contingencia con las tres variables
tabla_contingencia = pd.crosstab(index=df['genero'], columns=df['ponderacion'] , margins=True).head(3)

print(tabla_contingencia)
# Realizamos la prueba de chi-cuadrado
chi2, p, dof, expected = chi2_contingency(tabla_contingencia)

# Imprimimos los resultados
print('Estadístico de prueba chi-cuadrado: ', chi2)
print('Valor p: ', p)
print('Grados de libertad: ', dof)

# Creamos una tabla de contingencia de la causa de la amenaza con el nivel de riesgo
#tabla_contingencia = pd.crosstab(index=df['subversion'], columns=df['ponderacion'] , margins=True).head(3)
tabla_contingencia = pd.crosstab(index=df['laboral'], columns=df['ponderacion'] , margins=True).head(3)
#tabla_contingencia = pd.crosstab(index=df['personal'], columns=df['ponderacion'] , margins=True).head(3)
#tabla_contingencia = pd.crosstab(index=df['politico'], columns=df['ponderacion'] , margins=True).head(3)
#tabla_contingencia = pd.crosstab(index=df['economico'], columns=df['ponderacion'] , margins=True).head(3)

# Creamos una tabla de contingencia de la origen de la amenaza con el nivel de riesgo
#tabla_contingencia = pd.crosstab(index=df['grupos_armados'], columns=df['ponderacion'] , margins=True).head(3)
#tabla_contingencia = pd.crosstab(index=df['conocido'], columns=df['ponderacion'] , margins=True).head(3)
#tabla_contingencia = pd.crosstab(index=df['delincuencia_organizada'], columns=df['ponderacion'] , margins=True).head(3)
#tabla_contingencia = pd.crosstab(index=df['delincuencia_comun'], columns=df['ponderacion'] , margins=True).head(3)
#tabla_contingencia = pd.crosstab(index=df['desconocido'], columns=df['ponderacion'] , margins=True).head(3)


print(tabla_contingencia)
# Realizamos la prueba de chi-cuadrado
chi2, p, dof, expected = chi2_contingency(tabla_contingencia)

# Imprimimos los resultados
print('Estadístico de prueba chi-cuadrado: ', chi2)
print('Valor p: ', p)
print('Grados de libertad: ', dof)

"""ONE HOT ENCODING_tratamietno variables dicotómicas

dummy_genero= pd.get_dummies(df["genero"], prefix="Genero")
dummy_genero.head(5)""

#realizando este proceso se puede eliminar la columna de genero, que ya no se utilizara
df =df.drop(["genero"], axis=1)
#agregar la variable dummy creada 
df = pd.concat([df, dummy_genero], axis=1)
df.head(2)

#funcion para hacer el paso anterior con mas variables dicotomicas
def createdummies (df, varname):
  dummy =pd.get_dummies(df[varname], prefix= varname)
  df = df.drop(varname, axis=1)
  df= pd.concat([df, dummy], axis= 1)
  return df

createdummies(df, "subversion")
"""